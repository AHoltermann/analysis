//____________________________________________________________________________..
//
// This is a template for a Fun4All SubsysReco module with all methods from the
// $OFFLINE_MAIN/include/fun4all/SubsysReco.h baseclass
// You do not have to implement all of them, you can just remove unused methods
// here and in IsolatedTrackAnalysis.h.
//
// IsolatedTrackAnalysis(const std::string &name = "IsolatedTrackAnalysis")
// everything is keyed to IsolatedTrackAnalysis, duplicate names do work but it makes
// e.g. finding culprits in logs difficult or getting a pointer to the module
// from the command line
//
// IsolatedTrackAnalysis::~IsolatedTrackAnalysis()
// this is called when the Fun4AllServer is deleted at the end of running. Be
// mindful what you delete - you do loose ownership of object you put on the node tree
//
// int IsolatedTrackAnalysis::Init(PHCompositeNode *topNode)
// This method is called when the module is registered with the Fun4AllServer. You
// can create historgrams here or put objects on the node tree but be aware that
// modules which haven't been registered yet did not put antyhing on the node tree
//
// int IsolatedTrackAnalysis::InitRun(PHCompositeNode *topNode)
// This method is called when the first event is read (or generated). At
// this point the run number is known (which is mainly interesting for raw data
// processing). Also all objects are on the node tree in case your module's action
// depends on what else is around. Last chance to put nodes under the DST Node
// We mix events during readback if branches are added after the first event
//
// int IsolatedTrackAnalysis::process_event(PHCompositeNode *topNode)
// called for every event. Return codes trigger actions, you find them in
// $OFFLINE_MAIN/include/fun4all/Fun4AllReturnCodes.h
//   everything is good:
//     return Fun4AllReturnCodes::EVENT_OK
//   abort event reconstruction, clear everything and process next event:
//     return Fun4AllReturnCodes::ABORT_EVENT; 
//   proceed but do not save this event in output (needs output manager setting):
//     return Fun4AllReturnCodes::DISCARD_EVENT; 
//   abort processing:
//     return Fun4AllReturnCodes::ABORT_RUN
// all other integers will lead to an error and abort of processing
//
// int IsolatedTrackAnalysis::ResetEvent(PHCompositeNode *topNode)
// If you have internal data structures (arrays, stl containers) which needs clearing
// after each event, this is the place to do that. The nodes under the DST node are cleared
// by the framework
//
// int IsolatedTrackAnalysis::EndRun(const int runnumber)
// This method is called at the end of a run when an event from a new run is
// encountered. Useful when analyzing multiple runs (raw data). Also called at
// the end of processing (before the End() method)
//
// int IsolatedTrackAnalysis::End(PHCompositeNode *topNode)
// This is called at the end of processing. It needs to be called by the macro
// by Fun4AllServer::End(), so do not forget this in your macro
//
// int IsolatedTrackAnalysis::Reset(PHCompositeNode *topNode)
// not really used - it is called before the dtor is called
//
// void IsolatedTrackAnalysis::Print(const std::string &what) const
// Called from the command line - useful to print information when you need it
//
//____________________________________________________________________________..

#include "IsolatedTrackAnalysis.h"

// Cluster/Calorimeter includes
//#include <calobase/RawCluster.h>

// Tracking includes
#include <trackbase_historic/SvtxTrack.h>
#include <trackbase_historic/SvtxTrackMap.h>
#include <trackbase_historic/SvtxTrackState.h>
#include <trackbase_historic/SvtxVertexMap.h>

// Tower geometry includes
#include <calobase/RawCluster.h>
#include <calobase/RawClusterContainer.h>
#include <calobase/RawClusterUtility.h>
#include <calobase/RawTowerGeomContainer_Cylinderv1.h>

// G4 truth includes
#include <g4eval/SvtxEvalStack.h>
#include <g4main/PHG4Particle.h>
#include <g4main/PHG4TruthInfoContainer.h>

// Fun4All includes
#include <fun4all/Fun4AllReturnCodes.h>
#include <phool/PHCompositeNode.h>
#include <phool/getClass.h>

// Acts includes
#include <Acts/Definitions/Algebra.hpp>

// ROOT includes
#include <TFile.h>
#include <TTree.h>

// System includes
#include <iostream>
#include <cmath>
#include <string>
#include <vector>

//____________________________________________________________________________..
IsolatedTrackAnalysis::IsolatedTrackAnalysis(const std::string &name, const std::string &fileName):
  SubsysReco(name),
  m_outputFileName(fileName),
  m_minClusterEnergy(0.25),
  m_analyzeTracks(true),
  m_analyzeClusters(true),
  m_analyzeHepMCTruth(true),
  m_analyzeG4Truth(true)
{  
  /*m_partid1 = -99;
  m_partid2 = -99;
  m_x1 = -99;
  m_x2 = -99;
  m_mpi = -99;
  m_process_id = -99;*/

  initializeTrees();
}

//____________________________________________________________________________..
IsolatedTrackAnalysis::~IsolatedTrackAnalysis()
{
  delete m_tracktree;
  delete m_clustertree;
  //delete m_hepmctree;
  //delete m_g4tree;
}

//____________________________________________________________________________..
int IsolatedTrackAnalysis::Init(PHCompositeNode *topNode)
{
  m_outputFile = new TFile(m_outputFileName.c_str(), "RECREATE");
  counter = 0;

  if(counter % 100 == 0)
    std::cout << counter << " events are processed!" << std::endl;

  return Fun4AllReturnCodes::EVENT_OK;
}

//____________________________________________________________________________..
int IsolatedTrackAnalysis::InitRun(PHCompositeNode *topNode)
{

  RawTowerGeomContainer_Cylinderv1* cemcGeomContainer = findNode::getClass<RawTowerGeomContainer_Cylinderv1>(topNode, "TOWERGEOM_CEMC");
  RawTowerGeomContainer_Cylinderv1* ihcalGeomContainer = findNode::getClass<RawTowerGeomContainer_Cylinderv1>(topNode, "TOWERGEOM_HCALIN");
  RawTowerGeomContainer_Cylinderv1* ohcalGeomContainer = findNode::getClass<RawTowerGeomContainer_Cylinderv1>(topNode, "TOWERGEOM_HCALOUT");
  
  if(!cemcGeomContainer){
    std::cout << "ERROR: TOWERGEOM_CEMC not found" << std::endl;
  }
  if(!ihcalGeomContainer){
    std::cout << "ERROR: TOWERGEOM_HCALIN not found" << std::endl;
  }
  if(!ohcalGeomContainer){
    std::cout << "ERROR: TOWERGEOM_HCALOUT not found" << std::endl;
  }

  m_cemcRadius = cemcGeomContainer->get_radius();
  m_ihcalRadius = ihcalGeomContainer->get_radius();
  m_ohcalRadius = ohcalGeomContainer->get_radius();

  return Fun4AllReturnCodes::EVENT_OK;
}

//____________________________________________________________________________..
int IsolatedTrackAnalysis::process_event(PHCompositeNode *topNode)
{
  if(m_analyzeTracks){ getTracks(topNode); }
  if(m_analyzeClusters){ getClusters(topNode); }
  if(m_analyzeHepMCTruth){ getHepMCTruth(topNode); }
  if(m_analyzeG4Truth){ getG4Truth(topNode); }

  counter++;

  if(counter % 100 == 0)
    std::cout << counter << " events processed" << std::endl;

  return Fun4AllReturnCodes::EVENT_OK;
}

//____________________________________________________________________________..
int IsolatedTrackAnalysis::ResetEvent(PHCompositeNode *topNode)
{
  // Basic track properties
  m_tr_p.clear();
  m_tr_pt.clear();
  m_tr_eta.clear();
  m_tr_phi.clear();
  m_tr_charge.clear();
  m_tr_chisq.clear();
  m_tr_ndf.clear();
  
  // Distance of closest approach
  m_tr_dca_xy.clear();
  m_tr_dca_xy_error.clear();
  m_tr_dca_z.clear();
  m_tr_dca_z_error.clear();

  // Initial point of track
  m_tr_x.clear();
  m_tr_y.clear();
  m_tr_z.clear();

  // Vertex id of track
  m_tr_vertex_id.clear();

  // Vertex ids and positions, also stored on track tree
  m_vertex_id.clear();
  m_vx.clear();
  m_vy.clear();
  m_vz.clear();

  // Projection of track to calorimeters
  // CEMC
  m_tr_cemc_eta.clear();
  m_tr_cemc_phi.clear();
  // Inner HCAL
  m_tr_ihcal_eta.clear();
  m_tr_ihcal_phi.clear();
  /// Outer HCAL
  m_tr_ohcal_eta.clear();
  m_tr_ohcal_phi.clear();

  // Matched truth track
  m_tr_truth_is_primary.clear();
  m_tr_truth_pid.clear();
  m_tr_truth_e.clear();
  m_tr_truth_pt.clear();
  m_tr_truth_eta.clear();
  m_tr_truth_phi.clear();


  // EMCal clusters
  m_cl_cemc_e.clear();
  m_cl_cemc_eta.clear();
  m_cl_cemc_phi.clear();
  m_cl_cemc_r.clear();
  m_cl_cemc_z.clear();

  // Inner HCAL clusters
  m_cl_ihcal_e.clear();
  m_cl_ihcal_eta.clear();
  m_cl_ihcal_phi.clear();
  m_cl_ihcal_r.clear();
  m_cl_ihcal_z.clear();

  // Outer HCAL clusters
  m_cl_ohcal_e.clear();
  m_cl_ohcal_eta.clear();
  m_cl_ohcal_phi.clear();
  m_cl_ohcal_r.clear();
  m_cl_ohcal_z.clear();

  return Fun4AllReturnCodes::EVENT_OK;
}

//____________________________________________________________________________..
int IsolatedTrackAnalysis::End(PHCompositeNode *topNode)
{
  m_outputFile->cd();
  m_tracktree->Write();
  m_clustertree->Write();
  m_outputFile->Close();
  return Fun4AllReturnCodes::EVENT_OK;
}


//////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////
// Function extracting tracks //
////////////////////////////////

void IsolatedTrackAnalysis::getTracks(PHCompositeNode *topNode)
{
  SvtxTrackMap *trackmap = findNode::getClass<SvtxTrackMap>(topNode, "SvtxTrackMap");

  // Check whether SvtxTrackMap is present in the node tree or not
  if (!trackmap)
  {
    std::cout << PHWHERE
         << "SvtxTrackMap node is missing, can't collect tracks"
         << std::endl;
    return;
  }

  SvtxVertexMap *vertexmap = findNode::getClass<SvtxVertexMap>(topNode, "SvtxVertexMap");

  // Check whether SvtxTrackMap is present in the node tree or not
  if (!vertexmap)
  {
    std::cout << PHWHERE
         << "SvtxVertexMap node is missing, can't collect tracks"
         << std::endl;
    return;
  }

  /// EvalStack for truth track matching
  if(!m_svtxEvalStack){ m_svtxEvalStack = new SvtxEvalStack(topNode); }
  
  m_svtxEvalStack->next_event(topNode);

  /// Get the track evaluator
  SvtxTrackEval *trackeval = m_svtxEvalStack->get_track_eval();

  /// Get the range for primary tracks
  PHG4TruthInfoContainer *truthinfo = findNode::getClass<PHG4TruthInfoContainer>(topNode, "G4TruthInfo");


  // Looping over tracks in an event
  for(auto entry : *trackmap)
  {
    SvtxTrack *track = entry.second;

    m_tr_p.push_back( track->get_p() );
    m_tr_pt.push_back( track->get_pt() );
    m_tr_eta.push_back( track->get_eta() );
    m_tr_phi.push_back( track->get_phi() );
  
    m_tr_charge.push_back( track->get_charge() );
    m_tr_chisq.push_back( track->get_chisq() );
    m_tr_ndf.push_back( track->get_ndf() );

    float dca_xy, dca_z, dca_xy_error, dca_z_error;
    calculateDCA(track, vertexmap, dca_xy, dca_z, dca_xy_error, dca_z_error);

    m_tr_dca_xy.push_back( dca_xy );
    m_tr_dca_xy_error.push_back( dca_xy_error );
    m_tr_dca_z.push_back( dca_z );
    m_tr_dca_z_error.push_back( dca_z_error );

    m_tr_x.push_back( track->get_x() );
    m_tr_y.push_back( track->get_y() );
    m_tr_z.push_back( track->get_z() );

    m_tr_vertex_id.push_back( track->get_vertex_id() );

    // Project tracks to CEMC
    if(track->find_state(m_cemcRadius) != track->end_states()){
      m_tr_cemc_eta.push_back( calculateProjectionEta( track->find_state(m_cemcRadius)->second) );
      m_tr_cemc_phi.push_back( calculateProjectionPhi( track->find_state(m_cemcRadius)->second) );
    }
    else{
      m_tr_cemc_eta.push_back( -999 );
      m_tr_cemc_phi.push_back( -999 );
    }
    
    // Project tracks to inner HCAL
    if(track->find_state(m_ihcalRadius) != track->end_states()){
      m_tr_ihcal_eta.push_back( calculateProjectionEta( track->find_state(m_ihcalRadius)->second) );
      m_tr_ihcal_phi.push_back( calculateProjectionPhi( track->find_state(m_ihcalRadius)->second) );
    }
    else{
      m_tr_ihcal_eta.push_back( -999 );
      m_tr_ihcal_phi.push_back( -999 );
    }

    // Project tracks to outer HCAL
    if(track->find_state(m_ohcalRadius) != track->end_states()){
      m_tr_ohcal_eta.push_back( calculateProjectionEta( track->find_state(m_ohcalRadius)->second) );
      m_tr_ohcal_phi.push_back( calculateProjectionPhi( track->find_state(m_ohcalRadius)->second) );
    }
    else{
      m_tr_ohcal_eta.push_back( -999 );
      m_tr_ohcal_phi.push_back( -999 );
    }
    
    // Matching SvtxTracks to G4 truth
    PHG4Particle *truthtrack = trackeval->max_truth_particle_by_nclusters(track);

    if(truthtrack){
      m_tr_truth_pid.push_back(truthtrack->get_pid());
      m_tr_truth_is_primary.push_back(truthinfo->is_primary(truthtrack));
  
      m_tr_truth_e.push_back(truthtrack->get_e());

      float px = truthtrack->get_px();
      float py = truthtrack->get_py();
      float pz = truthtrack->get_pz();

      m_tr_truth_pt.push_back( sqrt(px*px+py*py) );
      m_tr_truth_phi.push_back( atan2(py, px) );
      m_tr_truth_eta.push_back( atanh(pz/sqrt(px*px+py*py+pz*pz)) );
    }
    else{
      m_tr_truth_pid.push_back( -999 );
      m_tr_truth_is_primary.push_back( -999 );
      m_tr_truth_e.push_back( -999 );
      m_tr_truth_pt.push_back( -999 );
      m_tr_truth_eta.push_back( -999 );
      m_tr_truth_phi.push_back( -999 );
    }
  }


  for(auto entry : *vertexmap)
  {
    SvtxVertex *vertex = entry.second;
    
    m_vertex_id.push_back( vertex->get_id() );
    m_vx.push_back( vertex->get_x() );
    m_vy.push_back( vertex->get_y() );
    m_vz.push_back( vertex->get_z() );
  }

  m_tracktree->Fill();
}

//////////////////////////////////
// Function extracting clusters //
//////////////////////////////////
void IsolatedTrackAnalysis::getClusters(PHCompositeNode *topNode){
  RawClusterContainer *cemcContainer = findNode::getClass<RawClusterContainer>(topNode,"CLUSTER_CEMC"); 
  
  // Check whether CLUSTER_CEMC is present in the node tree or not
  if (!cemcContainer)
  {
    std::cout << PHWHERE
         << "CLUSTER_CEMC node is missing, can't collect EMCal clusters"
         << std::endl;
    return;
  }

  RawClusterContainer::Map cemcMap = cemcContainer->getClustersMap();
  for(auto entry : cemcMap){
    RawCluster* cluster = entry.second;

    if(cluster->get_energy() > m_minClusterEnergy){
      // calculating eta
      // we need the nominal eta, with respect to the origin, not the vertex!
      CLHEP::Hep3Vector origin(0, 0, 0);
      CLHEP::Hep3Vector cluster_vector = RawClusterUtility::GetECoreVec(*cluster, origin);
       
      m_cl_cemc_e.push_back( cluster->get_energy() );
      m_cl_cemc_eta.push_back( cluster_vector.pseudoRapidity() );
      m_cl_cemc_phi.push_back( cluster->get_phi() );
      m_cl_cemc_r.push_back( cluster->get_r() );
      m_cl_cemc_z.push_back( cluster->get_z() );
    }

  }


  RawClusterContainer *ihcalContainer = findNode::getClass<RawClusterContainer>(topNode,"CLUSTER_HCALIN"); 
  
   // Check whether CLUSTER_HCALIN is present in the node tree or not
  if (!ihcalContainer)
  {
    std::cout << PHWHERE
         << "CLUSTER_HCALIN node is missing, can't collect EMCal clusters"
         << std::endl;
    return;
  }

  RawClusterContainer::Map ihcalMap = ihcalContainer->getClustersMap();
  for(auto entry : ihcalMap){
    RawCluster* cluster = entry.second;

    if(cluster->get_energy() > m_minClusterEnergy){
      // calculating eta
      // we need the nominal eta, with respect to the origin, not the vertex!
      CLHEP::Hep3Vector origin(0, 0, 0);
      CLHEP::Hep3Vector cluster_vector = RawClusterUtility::GetECoreVec(*cluster, origin);
      
      m_cl_ihcal_e.push_back( cluster->get_energy() );
      m_cl_ihcal_eta.push_back( cluster_vector.pseudoRapidity() );
      m_cl_ihcal_phi.push_back( cluster->get_phi() );
      m_cl_ihcal_r.push_back( cluster->get_r() );
      m_cl_ihcal_z.push_back( cluster->get_z() );
    }

  } 
  
  RawClusterContainer *ohcalContainer = findNode::getClass<RawClusterContainer>(topNode,"CLUSTER_HCALOUT");   

   // Check whether CLUSTER_HCALOUT is present in the node tree or not
  if (!ohcalContainer)
  {
    std::cout << PHWHERE
         << "CLUSTER_HCALOUT node is missing, can't collect EMCal clusters"
         << std::endl;
    return;
  }

  RawClusterContainer::Map ohcalMap = ohcalContainer->getClustersMap();
  for(auto entry : ohcalMap){
    RawCluster* cluster = entry.second;

    if(cluster->get_energy() > m_minClusterEnergy){
      // calculating eta
      // we need the nominal eta, with respect to the origin, not the vertex!
      CLHEP::Hep3Vector origin(0, 0, 0);
      CLHEP::Hep3Vector cluster_vector = RawClusterUtility::GetECoreVec(*cluster, origin);
 
      m_cl_ohcal_e.push_back( cluster->get_energy() );
      m_cl_ohcal_eta.push_back( cluster_vector.pseudoRapidity() );
      m_cl_ohcal_phi.push_back( cluster->get_phi() );
      m_cl_ohcal_r.push_back( cluster->get_r() );
      m_cl_ohcal_z.push_back( cluster->get_z() );
    }
  }

  m_clustertree->Fill();
}

void IsolatedTrackAnalysis::getHepMCTruth(PHCompositeNode *topNode){}
void IsolatedTrackAnalysis::getG4Truth(PHCompositeNode *topNode){}

////////////////////////////
// Track helper functions //
////////////////////////////

float IsolatedTrackAnalysis::calculateProjectionEta(SvtxTrackState* projectedState){
  float x = projectedState->get_x();// - initialState->get_x();
  float y = projectedState->get_y();// - initialState->get_y();
  float z = projectedState->get_z();// - initialState->get_z();

  float theta = acos(z / sqrt(x*x + y*y + z*z) );

  return -log( tan(theta/2.0) );
}

float IsolatedTrackAnalysis::calculateProjectionPhi(SvtxTrackState* projectedState){
  float x = projectedState->get_x();// - initialState->get_x();
  float y = projectedState->get_y();// - initialState->get_y();
 
  return atan2(y,x);
}

// From SvtxEval.cc
void IsolatedTrackAnalysis::calculateDCA(SvtxTrack* track, SvtxVertexMap* vertexmap,
          float& dca3dxy, float& dca3dz,
          float& dca3dxysigma, float& dca3dzsigma)
{
  Acts::Vector3 pos(track->get_x(),
        track->get_y(),
        track->get_z());
  Acts::Vector3 mom(track->get_px(),
        track->get_py(),
        track->get_pz());

  auto vtxid = track->get_vertex_id();
  auto svtxVertex = vertexmap->get(vtxid);
  if(!svtxVertex)
    { return; }
  Acts::Vector3 vertex(svtxVertex->get_x(),
           svtxVertex->get_y(),
           svtxVertex->get_z());

  pos -= vertex;

  Acts::ActsSymMatrix<3> posCov;
  for(int i = 0; i < 3; ++i)
    {
      for(int j = 0; j < 3; ++j)
  {
    posCov(i, j) = track->get_error(i, j);
  } 
    }
  
  Acts::Vector3 r = mom.cross(Acts::Vector3(0.,0.,1.));
  float phi = atan2(r(1), r(0));
  
  Acts::RotationMatrix3 rot;
  Acts::RotationMatrix3 rot_T;
  rot(0,0) = cos(phi);
  rot(0,1) = -sin(phi);
  rot(0,2) = 0;
  rot(1,0) = sin(phi);
  rot(1,1) = cos(phi);
  rot(1,2) = 0;
  rot(2,0) = 0;
  rot(2,1) = 0;
  rot(2,2) = 1;
  
  rot_T = rot.transpose();

  Acts::Vector3 pos_R = rot * pos;
  Acts::ActsSymMatrix<3> rotCov = rot * posCov * rot_T;

  dca3dxy = pos_R(0);
  dca3dz = pos_R(2);
  dca3dxysigma = sqrt(rotCov(0,0));
  dca3dzsigma = sqrt(rotCov(2,2));
  
}


///////////////////////////////////
// Function to set tree branches //
///////////////////////////////////

void IsolatedTrackAnalysis::initializeTrees()
{
  ////////////////
  // Track tree //
  ////////////////
  m_tracktree = new TTree("tracktree", "Tree of svtx tracks");
  
  // Basic properties
  m_tracktree->Branch("m_tr_p",  &m_tr_p);
  m_tracktree->Branch("m_tr_pt",  &m_tr_pt);
  m_tracktree->Branch("m_tr_eta", &m_tr_eta);
  m_tracktree->Branch("m_tr_phi", &m_tr_phi);
  m_tracktree->Branch("m_tr_charge", &m_tr_charge);
  m_tracktree->Branch("m_tr_chisq",  &m_tr_chisq);
  m_tracktree->Branch("m_tr_ndf",    &m_tr_ndf);
  
  // Distance of closest approach
  m_tracktree->Branch("m_tr_dca_xy", &m_tr_dca_xy);
  m_tracktree->Branch("m_tr_dca_xy_error", &m_tr_dca_xy_error);
  m_tracktree->Branch("m_tr_dca_z",  &m_tr_dca_z);
  m_tracktree->Branch("m_tr_dca_z_error", &m_tr_dca_z_error);

  // Initial point of track
  m_tracktree->Branch("m_tr_x", &m_tr_x);
  m_tracktree->Branch("m_tr_y", &m_tr_y);
  m_tracktree->Branch("m_tr_z", &m_tr_z);

  // Vertex id of track
  m_tracktree->Branch("m_tr_vertex_id", &m_tr_vertex_id);
  
  // Vertex ids and positions, also stored on track tree
  m_tracktree->Branch("m_vertex_id", &m_vertex_id);
  m_tracktree->Branch("m_vx", &m_vx);
  m_tracktree->Branch("m_vy", &m_vy);
  m_tracktree->Branch("m_vz", &m_vz);

  // Projection of track to calorimeters
  // CEMC
  m_tracktree->Branch("m_tr_cemc_eta", &m_tr_cemc_eta);
  m_tracktree->Branch("m_tr_cemc_phi", &m_tr_cemc_phi);
  // Inner HCAL
  m_tracktree->Branch("m_tr_ihcal_eta", &m_tr_ihcal_eta);
  m_tracktree->Branch("m_tr_ihcal_phi", &m_tr_ihcal_phi);
  /// Outer HCAL
  m_tracktree->Branch("m_tr_ohcal_eta", &m_tr_ohcal_eta);
  m_tracktree->Branch("m_tr_ohcal_phi", &m_tr_ohcal_phi);

  // Matched truth track
  m_tracktree->Branch("m_tr_truth_pid", &m_tr_truth_pid);
  m_tracktree->Branch("m_tr_truth_is_primary",&m_tr_truth_is_primary);
  m_tracktree->Branch("m_tr_truth_e", &m_tr_truth_e);
  m_tracktree->Branch("m_tr_truth_pt", &m_tr_truth_pt);
  m_tracktree->Branch("m_tr_truth_eta", &m_tr_truth_eta);
  m_tracktree->Branch("m_tr_truth_phi", &m_tr_truth_phi);

  //////////////////
  // Cluster tree //
  //////////////////
  m_clustertree = new TTree("clustertree", "Tree of raw clusters");
 
  // CEMC clusters
  m_clustertree->Branch("m_cl_cemc_e", &m_cl_cemc_e);
  m_clustertree->Branch("m_cl_cemc_eta", &m_cl_cemc_eta);
  m_clustertree->Branch("m_cl_cemc_phi", &m_cl_cemc_phi);
  m_clustertree->Branch("m_cl_cemc_r", &m_cl_cemc_r);
  m_clustertree->Branch("m_cl_cemc_z", &m_cl_cemc_z);

  // Inner HCAL clusters
  m_clustertree->Branch("m_cl_ihcal_e", &m_cl_ihcal_e);
  m_clustertree->Branch("m_cl_ihcal_eta", &m_cl_ihcal_eta);
  m_clustertree->Branch("m_cl_ihcal_phi", &m_cl_ihcal_phi);
  m_clustertree->Branch("m_cl_ihcal_r", &m_cl_ihcal_r);
  m_clustertree->Branch("m_cl_ihcal_z", &m_cl_ihcal_z);

  // Outer HCAL clusters
  m_clustertree->Branch("m_cl_ohcal_e", &m_cl_ohcal_e);
  m_clustertree->Branch("m_cl_ohcal_eta", &m_cl_ohcal_eta);
  m_clustertree->Branch("m_cl_ohcal_phi", &m_cl_ohcal_phi);
  m_clustertree->Branch("m_cl_ohcal_r", &m_cl_ohcal_r);
  m_clustertree->Branch("m_cl_ohcal_z", &m_cl_ohcal_z);

  /////////////////////////
  // HepMC particle tree //
  /////////////////////////

  /*m_hepmctree = new TTree("hepmctree","Tree of truth hepmc info and particles");
  
  m_hepmctree->Branch("m_partid1", &m_partid1, "m_partid1/I");
  m_hepmctree->Branch("m_partid2", &m_partid2, "m_partid2/I");
  m_hepmctree->Branch("m_x1", &m_x1, "m_x1/F");
  m_hepmctree->Branch("m_x2", &m_x2, "m_x2/F");
  m_hepmctree->Branch("m_mpi", &m_mpi, "m_mpi/I");
  m_hepmctree->Branch("m_process_id", &m_process_id, "m_process_id/I");
  
 //m_hepmctree->Branch("m_hepmc_is_primary", m_hepmc_is_primary, "m_hepmc_is_primary[m_hepmcmult]/I");
  m_hepmctree->Branch("m_hepmc_pid", &m_hepmc_pid);
  m_hepmctree->Branch("m_hepmc_e", &m_hepmc_e);
  m_hepmctree->Branch("m_hepmc_pt", &m_hepmc_pt);
  m_hepmctree->Branch("m_hepmc_eta", &m_hepmc_eta);
  m_hepmctree->Branch("m_hepmc_phi", &m_hepmc_phi);
  */

  //////////////////////
  // G4 particle tree //
  //////////////////////

  /*m_g4tree = new TTree("g4tree","Tree of truth G4 particles");

  //m_g4tree->Branch("m_g4_is_primary", m_g4_is_primary, "m_g4_is_primary[m_g4mult]/I");
  m_g4tree->Branch("m_g4_pid", &m_g4_pid);
  m_g4tree->Branch("m_g4_e", &m_g4_e);
  m_g4tree->Branch("m_g4_pt", &m_g4_pt);
  m_g4tree->Branch("m_g4_eta", &m_g4_eta);
  m_g4tree->Branch("m_g4_phi", &m_g4_phi);*/
}
